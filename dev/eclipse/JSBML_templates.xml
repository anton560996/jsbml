<?xml version="1.0" encoding="UTF-8" standalone="no"?><templates><template autoinsert="true" context="java" deleted="false" description="getAllowsChildren-, getChildcount-, getChildAt-  methods" enabled="true" name="JSBML_Children">${:import(java.text.MessageFormat, org.sbml.jsbml.ListOf, org.sbml.jsbml.SBase)}&#13;
&#13;
@Override&#13;
public boolean getAllowsChildren() {	&#13;
  return ${true_false};&#13;
}&#13;
&#13;
public int getChildCount() {&#13;
  int count = super.getChildCount();&#13;
&#13;
&#13;
	// TODO: the following must be implemented for each XML child variable&#13;
  // if (isSetListOfFoos()) {&#13;
  //  count++;&#13;
  // }&#13;
&#13;
  return count;&#13;
}&#13;
&#13;
	public TreeNode getChildAt(int index) {&#13;
		if (index &lt; 0) {&#13;
			throw new IndexOutOfBoundsException(index + " &lt; 0");&#13;
		}&#13;
&#13;
		int count = super.getChildCount(), pos = 0;&#13;
		&#13;
		if (index &lt; count) {&#13;
			return super.getChildAt(index);&#13;
		} else {&#13;
			index -= count;&#13;
		}&#13;
&#13;
		// TODO: the following must be implemented for each ListOf* variable&#13;
		// if (isSetListOfFoos()) {&#13;
		//   if (pos == index) {&#13;
		//     return getListOfFoos();&#13;
		//   }&#13;
		//   pos++;&#13;
		// }&#13;
&#13;
		throw new IndexOutOfBoundsException(MessageFormat.format(&#13;
				"Index {0,number,integer} &gt;= {1,number,integer}",&#13; 
                index,&#13; Math.min(pos, 0)));&#13;
	}&#13;
	&#13;
</template><template autoinsert="false" context="java" deleted="false" description="Standard constructors for JSBML classes" enabled="true" name="JSBML_Constructors_id_name">/**&#13;
 * Creates an ${enclosing_type} instance &#13;
 */&#13;
public ${enclosing_type}() {&#13;
  super();&#13;
  initDefaults();&#13;
}&#13;
&#13;
/**&#13;
 * Creates a ${enclosing_type} instance with an id. &#13;
 * &#13;
 * @param id&#13;
 */&#13;
public ${enclosing_type}(String id) {&#13;
  super(id);&#13;
  initDefaults();&#13;
}&#13;
&#13;
/**&#13;
 * Creates a ${enclosing_type} instance with a level and version. &#13;
 * &#13;
 * @param level&#13;
 * @param version&#13;
 */&#13;
public ${enclosing_type}(int level, int version){&#13;
  this(null, null, level, version);&#13;
}&#13;
&#13;
/**&#13;
 * Creates a ${enclosing_type} instance with an id, level, and version. &#13;
 * &#13;
 * @param id&#13;
 * @param level&#13;
 * @param version&#13;
 */&#13;
public ${enclosing_type}(String id, int level, int version) {&#13;
  this(id, null, level, version);&#13;
}&#13;
&#13;
/**&#13;
 * Creates a ${enclosing_type} instance with an id, name, level, and version. &#13;
 * &#13;
 * @param id&#13;
 * @param name&#13;
 * @param level&#13;
 * @param version&#13;
 */&#13;
public ${enclosing_type}(String id, String name, int level, int version) {&#13;
  super(id, name, level, version);&#13;
  if (getLevelAndVersion().compareTo(Integer.valueOf(${Constant}.MIN_SBML_LEVEL), Integer.valueOf(${Constant}.MIN_SBML_VERSION)) &lt; 0) {&#13;
    throw new LevelVersionError(getElementName(), level, version);&#13;
  }&#13;
  initDefaults();&#13;
}&#13;
&#13;
/**&#13;
 * Clone constructor&#13;
 */&#13;
public ${enclosing_type}(${enclosing_type} obj) {&#13;
  super(obj);&#13;
&#13;
	// TODO: copy all class attributes, e.g.:&#13;
  // bar = obj.bar;&#13;
}&#13;
&#13;
/**&#13;
 * clones this class&#13;
 */&#13;
public ${enclosing_type} clone() {&#13;
    return new ${enclosing_type}(this);&#13;
}&#13;
&#13;
/**&#13;
 * Initializes the default values using the namespace.&#13;
 */&#13;
public void initDefaults() {&#13;
  addNamespace(${Constant}.namespaceURI);&#13;
  // TODO: init default values here if necessary, e.g.:&#13;
  // bar = null;&#13;
}&#13;
&#13;
</template><template autoinsert="true" context="java" deleted="false" description="get-, set-, isSets, unset-methods for SBML attributes" enabled="true" name="JSBML_getter_setter">${:import(org.sbml.jsbml.PropertyUndefinedError)}&#13;
/**&#13;
 * Returns the value of {@link #${field:var}}.&#13;
 *&#13;
 * @return the value of {@link #${field:var}}.&#13;
 */&#13;
public ${field_type} get${Field:var}() {&#13;
  //TODO: if variable is boolean, create an additional "isVar"&#13;
  //TODO: return primitive data type if possible (e.g., int instead of Integer)&#13;
  if (isSet${Field}()) {&#13;
    return ${field:var};&#13;
  }&#13;
  // This is necessary if we cannot return null here. For variables of type String return an empty String if no value is defined.&#13;
  throw new PropertyUndefinedError(${constant_class}.${field}, this);&#13;
}&#13;
&#13;
/**&#13;
 * Returns whether {@link #${field}} is set.&#13;
 *&#13;
 * @return whether {@link #${field}} is set.&#13;
 */&#13;
public boolean isSet${Field}() {&#13;
  return this.${field} != null;&#13;
}&#13;
&#13;
/**&#13;
 * Sets the value of ${field:var}&#13;
 * @param ${field} the value of ${field:var} to be set.
 */&#13;
public void set${Field}(${field_type} ${field}) {&#13;
  ${field_type} old${Field} = this.${field};&#13;
  this.${field} = ${field};&#13;
  firePropertyChange(${constant_class}.${field}, old${Field}, this.${field});&#13;
}&#13;
&#13;
/**&#13;
 * Unsets the variable ${field}.&#13;
 *&#13;
 * @return {@code true} if ${field} was set before, &#13;
 *         otherwise {@code false}.&#13;
 */&#13;
public boolean unset${Field}() {&#13;
  if (isSet${Field}()) {&#13;
    ${field_type} old${Field} = this.${field};&#13;
    this.${field} = null;&#13;
    firePropertyChange(${constant_class}.${field}, old${Field}, this.${field});&#13;
    return true;&#13;
  }&#13;
  return false;&#13;
}</template><template autoinsert="true" context="java" deleted="false" description="isSet-, get-, set-, unset-, add-, remove- methods for SBML ListOf element" enabled="true" name="JSBML_ListOfs">${:import(org.sbml.jsbml.ListOf)}&#13;
/**&#13;
 * Returns {@code true} if {@link #listOf${Field:var}s} contains at least one element.&#13;
 *&#13;
 * @return {@code true} if {@link #listOf${Field:var}s} contains at least one element, &#13;
 *         otherwise {@code false}.&#13;
 */&#13;
public boolean isSetListOf${Field:var}s() {&#13;
  if ((listOf${Field:var}s == null) || listOf${Field:var}s.isEmpty()) {&#13;
    return false;&#13;
  }&#13;
  return true;&#13;
}&#13;
&#13;
/**&#13;
 * Returns the {@link #listOf${Field:var}s}. Creates it if it is not already existing.&#13;
 *&#13;
 * @return the {@link #listOf${Field:var}s}.&#13;
 */&#13;
public ListOf&lt;${Field:var}&gt; getListOf${Field:var}s() {&#13;
  if (!isSetListOf${Field:var}s()) {&#13;
    listOf${Field:var}s = new ListOf&lt;${Field:var}&gt;();&#13;
    listOf${Field:var}s.setNamespace(${constant_class}.namespaceURI);&#13;
    listOf${Field:var}s.setSBaseListType(ListOf.Type.other);&#13;
&#13;
    // TODO - if the class containing this code is not of type SBasePlugin, replace the 3 lines by just "registerChild(listOf${Field:var}s);"&#13;
	if (isSetExtendedSBase()) {&#13;
	    extendedSBase.registerChild(listOf${Field:var}s);&#13;
	}&#13;
  }&#13;
  return listOf${Field:var}s;&#13;
}&#13;
&#13;
/**&#13;
 * Sets the given {@code ListOf&lt;${Field:var}&gt;}. If {@link #listOf${Field:var}s}&#13;
 * was defined before and contains some elements, they are all unset.&#13;
 *&#13;
 * @param listOf${Field:var}s&#13;
 */&#13;
public void setListOf${Field:var}s(ListOf&lt;${Field:var}&gt; listOf${Field:var}s) {&#13;
  unsetListOf${Field:var}s();&#13;
  this.listOf${Field:var}s = listOf${Field:var}s;&#13;
  this.listOf${Field:var}s.setSBaseListType(ListOf.Type.other);&#13;
&#13;
  // TODO - if the class containing this code is not of type SBasePlugin, replace the 3 lines by just "registerChild(listOf${Field:var}s);"&#13;
  if (isSetExtendedSBase()) {&#13;
	extendedSBase.registerChild(this.listOf${Field:var}s);&#13;
  }&#13;
}&#13;
&#13;
/**&#13;
 * Returns {@code true} if {@link #listOf${Field:var}s} contains at least one element, &#13;
 *         otherwise {@code false}.&#13;
 *&#13;
 * @return {@code true} if {@link #listOf${Field:var}s} contains at least one element, &#13;
 *         otherwise {@code false}.&#13;
 */&#13;
public boolean unsetListOf${Field:var}s() {&#13;
  if(isSetListOf${Field:var}s()) {&#13;
    ListOf&lt;${Field:var}&gt; old${Field:var}s = this.listOf${Field:var}s;&#13;
    this.listOf${Field:var}s = null;&#13;
    old${Field:var}s.fireNodeRemovedEvent();&#13;
    return true;&#13;
  }&#13;
  return false;&#13;
}&#13;
&#13;
/**&#13;
 * Adds a new {@link ${Field:var}} to the {@link #listOf${Field:var}s}.&#13;
 * &lt;p&gt;The listOf${Field:var}s is initialized if necessary.&#13;
 *&#13;
 * @param ${field:var} the element to add to the list&#13;
 * @return {@code true} (as specified by {@link java.util.Collection#add})&#13;
 * @see java.util.Collection#add(Object)&#13;
 */&#13;
public boolean add${Field:var}(${Field:var} ${field:var}) {&#13;
   return getListOf${Field:var}s().add(${field:var});&#13;
}&#13;
&#13;
/**&#13;
 * Removes an element from the {@link #listOf${Field:var}s}.&#13;
 *&#13;
 * @param ${field:var} the element to be removed from the list.&#13;
 * @return {@code true} if the list contained the specified element and it was removed.&#13;
 * @see java.util.List#remove(Object)&#13;
 */&#13;
public boolean remove${Field:var}(${Field:var} ${field:var}) {&#13;
  if (isSetListOf${Field:var}s()) {&#13;
    return getListOf${Field:var}s().remove(${field:var});&#13;
  }&#13;
  return false;&#13;
}&#13;
&#13;
// TODO - if ${Field:var} has no id attribute, you should remove this method.&#13;
/**&#13;
 * Removes an element from the {@link #listOf${Field:var}s}.&#13;
 *&#13;
 * @param ${field:var}Id the id of the element to be removed from the list.&#13;
 * @return the removed element, if it was successfully found and removed or {@code null}.&#13;
 */&#13;
public ${Field:var} remove${Field:var}(String ${field:var}Id) {&#13;
  if (isSetListOf${Field:var}s()) {&#13;
    return getListOf${Field:var}s().remove(${field:var}Id);&#13;
  }&#13;
  return null;&#13;
}&#13;
&#13;
/**&#13;
 * Removes an element from the listOf${Field:var}s at the given index.&#13;
 *&#13;
 * @param i the index where to remove the {@link ${Field:var}}.&#13;
 * @return the specified element if it was successfully found and removed.&#13;
 * @throws IndexOutOfBoundsException if the listOf is not set or&#13;
 * if the index is out of bound (index &lt; 0 || index &gt; list.size).&#13;
 */&#13;
public ${Field:var} remove${Field:var}(int i) {&#13;
  if (!isSetListOf${Field:var}s()) {&#13;
    throw new IndexOutOfBoundsException(Integer.toString(i));&#13;
  }&#13;
  return getListOf${Field:var}s().remove(i);&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * Creates a new ${Field:var} element and adds it to the ListOf${Field:var}s list.&#13;
 */&#13;
public ${Field:var} create${Field:var}() {&#13;
  return create${Field:var}(null);&#13;
}&#13;
&#13;
/**&#13;
 * Creates a new {@link ${Field:var}} element and adds it to the {@link #listOf${Field:var}s} list.&#13;
 *&#13;
 * @return a new {@link ${Field:var}} element.&#13;
 */&#13;
public ${Field:var} create${Field:var}(String id) {&#13;
  ${Field:var} ${field:var} = new ${Field:var}(id);&#13;
  add${Field:var}(${field:var});&#13;
  return ${field:var};&#13;
}&#13;
&#13;
/**&#13;
 * TODO: optionally, create additional create methods with more&#13;
 * variables, for instance "bar" variable&#13;
 */&#13;
// public ${Field:var} create${Field:var}(String id, int bar) {&#13;
//   ${Field:var} ${field:var} = create${Field:var}(id);&#13;
//   ${field:var}.setBar(bar);&#13;
//   return ${field:var};&#13;
// }&#13;
&#13;
/**&#13;
 * Gets an element from the {@link #listOf${Field:var}s} at the given index.&#13;
 *&#13;
 * @param i the index of the {@link ${Field:var}} element to get.&#13;
 * @return an element from the listOf${Field:var}s at the given index.&#13;
 * @throws IndexOutOfBoundsException if the listOf is not set or&#13;
 * if the index is out of bound (index &lt; 0 || index &gt; list.size).&#13;
 */&#13;
public ${Field:var} get${Field:var}(int i) {&#13;
  if (!isSetListOf${Field:var}s()) {&#13;
    throw new IndexOutOfBoundsException(Integer.toString(i));&#13;
  }&#13;
  return getListOf${Field:var}s().get(i);&#13;
}&#13;
&#13;
// TODO - if ${Field:var} has no id attribute, you should remove this method.&#13;
/**&#13;
 * Gets an element from the listOf${Field:var}s, with the given id.&#13;
 *&#13;
 * @param ${field:var}Id the id of the {@link ${Field:var}} element to get.&#13;
 * @return an element from the listOf${Field:var}s with the given id or {@code null}.&#13;
 */&#13;
public ${Field:var} get${Field:var}(String ${field:var}Id) {&#13;
  if (isSetListOf${Field:var}s()) {&#13;
    return getListOf${Field:var}s().get(${field:var}Id);&#13;
  }&#13;
  return null;&#13;
}&#13;
&#13;
/**&#13;
 * Returns the number of {@link ${Field:var}}s in this {@link ${enclosing_type}}.&#13;
 * &#13;
 * @return the number of {@link ${Field:var}}s in this {@link ${enclosing_type}}.&#13;
 */&#13;
public int get${Field:var}Count() {&#13;
  return isSetListOf${Field:var}s() ? getListOf${Field:var}s().size() : 0;&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * Returns the number of {@link ${Field:var}}s in this {@link ${enclosing_type}}.&#13;
 * &#13;
 * @return the number of {@link ${Field:var}}s in this {@link ${enclosing_type}}.&#13;
 * @libsbml.deprecated same as {@link #get${Field:var}Count()}&#13;
 */&#13;
public int getNum${Field:var}s() {&#13;
  return get${Field:var}Count();&#13;
}&#13;
&#13;
/**&#13;
 * &#13;
 */&#13;
private ListOf&lt;${Field:var}&gt; listOf${Field:var}s;</template><template autoinsert="true" context="java" deleted="false" description="writeXMLAttributes and readAttribute methods" enabled="true" name="JSBML_XML_methods">${:import(org.sbml.jsbml.util.StringTools,java.util.Map)}&#13;
public Map&lt;String, String&gt; writeXMLAttributes() {&#13;
  Map&lt;String, String&gt; attributes = super.writeXMLAttributes();&#13;
&#13;
//  TODO: this must be done for each class attribute&#13;
//  if (isSet${Field:var}()) {&#13;
//    attributes.remove(${constants_class}.${field:var});&#13;
//    attributes.put(${constants_class}.shortLabel + ":" + ${constants_class}.${field:var}, get${Field:var}());&#13;
//  }&#13;
  return attributes;&#13;
}&#13;
&#13;
public boolean readAttribute(String attributeName, String prefix, String value) {&#13;
&#13;
  boolean isAttributeRead = super.readAttribute(attributeName, prefix, value);&#13;
  if (!isAttributeRead) {&#13;
    isAttributeRead = true;&#13;
&#13;
		// TODO: this must be done for each attribute&#13;
    if (attributeName.equals(${constants_class}.${field:var})) {&#13;
      set${Field:var}(StringTools.parseSBMLInt(value));&#13;
    } &#13;
    // END TODO&#13;
      else {&#13;
      isAttributeRead = false;&#13;
    }&#13;
  }&#13;
&#13;
  return isAttributeRead;&#13;
}</template></templates>