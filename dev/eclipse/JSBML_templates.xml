<?xml version="1.0" encoding="UTF-8" standalone="no"?><templates><template autoinsert="true" context="java" deleted="false" description="getAllowsChildren-, getChildcount-, getChildAt-  methods" enabled="true" name="JSBML_Children">${:import(java.text.MessageFormat, org.sbml.jsbml.ListOf, org.sbml.jsbml.SBase)}&#13;
&#13;
@Override&#13;
public boolean getAllowsChildren() {	&#13;
  // TODO: Check if this method must really be overritten&#13;
  return ${yes_no};&#13;
}&#13;
&#13;
public int getChildCount() {&#13;
  int count = 0;&#13;
&#13;
	// TODO: the following must be implemented for each ListOf* variable&#13;
  // if (isSetListOfFoos()) {&#13;
  //  count++;&#13;
  // }&#13;
&#13;
  return count;&#13;
}&#13;
&#13;
&#13;
public SBase getChildAt(int childIndex) {&#13;
  if (childIndex &lt; 0) {&#13;
    throw new IndexOutOfBoundsException(childIndex + " &lt; 0");&#13;
  }&#13;
&#13;
  int pos = 0;&#13;
	// TODO: the following must be implemented for each ListOf* variable&#13;
  // if (isSetListOfFoos()) {&#13;
  //   if (pos == childIndex) {&#13;
  //     return getListOfFoos();&#13;
  //   }&#13;
  //   pos++;&#13;
  // }&#13;
&#13;
  throw new IndexOutOfBoundsException(MessageFormat.format("Index {0,number,integer} &gt;= {1,number,integer}", childIndex, +((int) Math.min(pos, 0))));&#13;
}</template><template autoinsert="false" context="java" deleted="false" description="Standard constructors for JSBML classes" enabled="true" name="JSBML_Constructors">/**&#13;
 * Creates an ${enclosing_type} instance &#13;
 */&#13;
public ${enclosing_type}() {&#13;
  super();&#13;
  initDefaults();&#13;
}&#13;
&#13;
/**&#13;
 * Creates a ${enclosing_type} instance with an id. &#13;
 * &#13;
 * @param id&#13;
 */&#13;
public ${enclosing_type}(String id) {&#13;
  super(id);&#13;
  initDefaults();&#13;
}&#13;
&#13;
/**&#13;
 * Creates a ${enclosing_type} instance with a level and version. &#13;
 * &#13;
 * @param level&#13;
 * @param version&#13;
 */&#13;
public ${enclosing_type}(int level, int version){&#13;
  this(null, null, level, version);&#13;
}&#13;
&#13;
/**&#13;
 * Creates a ${enclosing_type} instance with an id, level, and version. &#13;
 * &#13;
 * @param id&#13;
 * @param level&#13;
 * @param version&#13;
 */&#13;
public ${enclosing_type}(String id, int level, int version) {&#13;
  this(id, null, level, version);&#13;
}&#13;
&#13;
/**&#13;
 * Creates a ${enclosing_type} instance with an id, name, level, and version. &#13;
 * &#13;
 * @param id&#13;
 * @param name&#13;
 * @param level&#13;
 * @param version&#13;
 */&#13;
public ${enclosing_type}(String id, String name, int level, int version) {&#13;
  super(id, name, level, version);&#13;
  if (getLevelAndVersion().compareTo(Integer.valueOf(MIN_SBML_LEVEL), Integer.valueOf(MIN_SBML_VERSION)) &lt; 0) {&#13;
    throw new LevelVersionError(getElementName(), level, version);&#13;
  }&#13;
  initDefaults();&#13;
}&#13;
&#13;
/**&#13;
 * Clone constructor&#13;
 */&#13;
public ${enclosing_type}(${enclosing_type} obj) {&#13;
  super(obj);&#13;
&#13;
	// TODO: copy all class attributes, e.g.:&#13;
  // bar = obj.bar;&#13;
}&#13;
&#13;
/**&#13;
 * clones this class&#13;
 */&#13;
public ${enclosing_type} clone() {&#13;
    return new ${enclosing_type}(this);&#13;
}&#13;
&#13;
/**&#13;
 * Initializes the default values using the namespace.&#13;
 */&#13;
public void initDefaults() {&#13;
  addNamespace(${constant_class}.namespaceURI);&#13;
  // TODO: init default values here if necessary, e.g.:&#13;
  // bar = null;&#13;
}&#13;
&#13;
public static final int MIN_SBML_LEVEL = ${3:level};&#13;
public static final int MIN_SBML_VERSION = ${1:version};</template><template autoinsert="true" context="java" deleted="false" description="get-, set-, isSets, unset-methods for SBML attributes" enabled="true" name="JSBML_getter_setter">${:import(org.sbml.jsbml.PropertyUndefinedError)}&#13;
/**&#13;
 * @return the value of ${field:var}&#13;
 */&#13;
public ${return_type} get${Field:var}() {&#13;
  //TODO: if variable is boolean, create an additional "isVar"&#13;
  //TODO: return primitive data type if possible (e.g. int instead of Integer)&#13;
  if (isSet${Field}()) {&#13;
    return ${field:var};&#13;
  }&#13;
  // This is necessary if we cannot return null here.&#13;
  throw new PropertyUndefinedError(${constant_class}.${field}, this);&#13;
}&#13;
&#13;
/**&#13;
 * @return whether ${field} is set &#13;
 */&#13;
public boolean isSet${Field}() {&#13;
  return this.${field} != null;&#13;
}&#13;
&#13;
/**&#13;
 * Set the value of ${field:var}&#13;
 */&#13;
public void set${Field}(int ${field}) {&#13;
  ${var_type:elemType(field)} old${Field} = this.${field};&#13;
  this.${field} = ${field};&#13;
  firePropertyChange(${constant_class}.${field}, old${Field}, this.${field});&#13;
}&#13;
&#13;
/**&#13;
 * Unsets the variable ${field} &#13;
 * @return &lt;code&gt;true&lt;/code&gt;, if ${field} was set before, &#13;
 *         otherwise &lt;code&gt;false&lt;/code&gt;&#13;
 */&#13;
public boolean unset${Field}() {&#13;
  if (isSet${Field}()) {&#13;
    ${var_type:elemType(field)} old${Field} = this.${field};&#13;
    this.${field} = null;&#13;
    firePropertyChange(${constant_class}.${field}, old${Field}, this.${field});&#13;
    return true;&#13;
  }&#13;
  return false;&#13;
}</template><template autoinsert="true" context="java" deleted="false" description="isSet-, get-, set-, unset-, add-, remove- methods for SBML ListOf element" enabled="true" name="JSBML_ListOfs">${:import(org.sbml.jsbml.ListOf)}&#13;
/**&#13;
 * @return &lt;code&gt;true&lt;/code&gt;, if listOf${Field:var}s contains at least one element, &#13;
 *         otherwise &lt;code&gt;false&lt;/code&gt;&#13;
 */&#13;
public boolean isSetListOf${Field:var}s() {&#13;
  if ((listOf${Field:var}s == null) || listOf${Field:var}s.isEmpty()) {&#13;
    return false;&#13;
  }&#13;
  return true;&#13;
}&#13;
&#13;
/**&#13;
 * @return the listOf${Field:var}s&#13;
 */&#13;
public ListOf&lt;${Field:var}&gt; getListOf${Field:var}s() {&#13;
  if (!isSetListOf${Field:var}s()) {&#13;
    listOf${Field:var}s = new ListOf&lt;${Field:var}&gt;(getLevel(), getVersion());&#13;
    listOf${Field:var}s.addNamespace(${constant_class}.namespaceURI);&#13;
    listOf${Field:var}s.setSBaseListType(ListOf.Type.other);&#13;
    registerChild(listOf${Field:var}s);&#13;
  }&#13;
  return listOf${Field:var}s;&#13;
}&#13;
&#13;
/**&#13;
 * @param listOf${Field:var}s&#13;
 */&#13;
public void setListOf${Field:var}s(ListOf&lt;${Field:var}&gt; listOf${Field:var}s) {&#13;
  unsetListOf${Field:var}s();&#13;
  this.listOf${Field:var}s = listOf${Field:var}s;&#13;
  registerChild(this.listOf${Field:var}s);&#13;
}&#13;
&#13;
/**&#13;
 * @return &lt;code&gt;true&lt;/code&gt;, if listOf${Field:var}s contained at least one element, &#13;
 *         otherwise &lt;code&gt;false&lt;/code&gt;&#13;
 */&#13;
public boolean unsetListOf${Field:var}s() {&#13;
  if(isSetListOf${Field:var}s()) {&#13;
    ListOf&lt;${Field:var}&gt; old${Field:var}s = this.listOf${Field:var}s;&#13;
    this.listOf${Field:var}s = null;&#13;
    old${Field:var}s.fireNodeRemovedEvent();&#13;
    return true;&#13;
  }&#13;
  return false;&#13;
}&#13;
&#13;
/**&#13;
 * @param ${field:var}&#13;
 */&#13;
public boolean add${Field:var}(${Field:var} ${field:var}) {&#13;
   return getListOf${Field:var}s().add(${field:var});&#13;
}&#13;
&#13;
/**&#13;
 * @param ${field:var}&#13;
 */&#13;
public boolean remove${Field:var}(${Field:var} ${field:var}) {&#13;
  if (isSetListOf${Field:var}s()) {&#13;
    return getListOf${Field:var}s().remove(${field:var});&#13;
  }&#13;
  return false;&#13;
}&#13;
&#13;
/**&#13;
 * @param i&#13;
 */&#13;
public void remove${Field:var}(int i) {&#13;
  if (!isSetListOf${Field:var}s()) {&#13;
    throw new IndexOutOfBoundsException(Integer.toString(i));&#13;
  }&#13;
  getListOf${Field:var}s().remove(i);&#13;
}&#13;
&#13;
/**&#13;
 * TODO: if the ID is mandatory for ${Field:var} objects, &#13;
 * one should also add this methods&#13;
 */&#13;
//public void remove${Field:var}(String id) {&#13;
//  getListOf${Field:var}s().removeFirst(new NameFilter(id));&#13;
//}&#13;
&#13;
/**&#13;
 * create a new ${Field:var} element and adds it to the ListOf${Field:var}s list&#13;
 * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt;&#13;
 * only use this method, if ID is not mandatory in ${Field:var}&#13;
 * otherwise use @see create${Field:var}(String id)!&lt;/p&gt;&#13;
 */&#13;
public ${Field:var} create${Field:var}() {&#13;
  return create${Field:var}(null);&#13;
}&#13;
&#13;
/**&#13;
 * create a new ${Field:var} element and adds it to the ListOf${Field:var}s list&#13;
 */&#13;
public ${Field:var} create${Field:var}(String id) {&#13;
  ${Field:var} ${field:var} = new ${Field:var}(id, getLevel(), getVersion());&#13;
  add${Field:var}(${field:var});&#13;
  return ${field:var};&#13;
}&#13;
&#13;
/**&#13;
 * TODO: optionally, create additional create methods with more&#13;
 * variables, for instance "bar" variable&#13;
 */&#13;
// public ${Field:var} create${Field:var}(String id, int bar) {&#13;
//   ${Field:var} ${field:var} = create${Field:var}(id);&#13;
//   ${field:var}.setBar(bar);&#13;
//   return ${field:var};&#13;
// }&#13;
&#13;
/**&#13;
 * &#13;
 */&#13;
private ListOf&lt;${Field:var}&gt; listOf${Field:var}s;</template><template autoinsert="true" context="java" deleted="false" description="writeXMLAttributes and readAttribute methods" enabled="true" name="JSBML_XML_methods">${:import(org.sbml.jsbml.util.StringTools,java.util.Map)}&#13;
public Map&lt;String, String&gt; writeXMLAttributes() {&#13;
  Map&lt;String, String&gt; attributes = super.writeXMLAttributes();&#13;
&#13;
//  TODO: this must be done for each class attribute&#13;
//  if (isSet${Field:var}()) {&#13;
//    attributes.remove("${field:var}");&#13;
//    attributes.put(${enclosing_type}.shortLabel + ":${field:var}", get${Field:var}());&#13;
//  }&#13;
  return attributes;&#13;
}&#13;
&#13;
public boolean readAttribute(String attributeName, String prefix, String value) {&#13;
&#13;
  boolean isAttributeRead = super.readAttribute(attributeName, prefix, value);&#13;
  if (!isAttributeRead) {&#13;
    isAttributeRead = true;&#13;
&#13;
		// TODO: this must be done for each attribute&#13;
    if (attributeName.equals(${constants_class}.${field:var})) {&#13;
      set${Field:var}(StringTools.parseSBMLInt(value));&#13;
    } &#13;
    // END TODO&#13;
      else {&#13;
      isAttributeRead = false;&#13;
    }&#13;
  }&#13;
&#13;
  return isAttributeRead;&#13;
}</template></templates>