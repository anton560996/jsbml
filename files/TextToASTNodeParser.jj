 /**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = false;}PARSER_BEGIN(TextToASTNodeParser)package org.sbml.jsbml.text.parser;import org.sbml.jsbml.*;import org.sbml.jsbml.ASTNode.Type;import java.util.ArrayList;public class TextToASTNodeParser{  private MathContainer container;  private void checkSize(ArrayList < ASTNode > arguments, int i) throws ParseException  {    if (arguments.size() > i)    {      throw new ParseException();    }  }}PARSER_END(TextToASTNodeParser)SKIP :{  " "| "\t"}TOKEN :{  < NUMBER :    ([ "0"-"9" ])+    (      "." ([ "0"-"9" ])+    )?  | "." ([ "0"-"9" ])+ >}TOKEN :{  < INTEGER : ([ "0"-"9" ])+ >}TOKEN :{  < EXPNUMBER : < NUMBER > [ "E", "e" ] ([ "+", "-" ])? < INTEGER > >}TOKEN :{  < STRING :    ([ "a"-"z", "A"-"Z" ])+ ([ "a"-"z", "A"-"Z", "0"-"9" ])*  | ([ "0"-"9" ])+ ([ "a"-"z", "A"-"Z" ]) ([ "a"-"z", "A"-"Z", "0"-"9" ])* >}TOKEN :{  < SLPITTER : [ "," ] >}TOKEN :{  < PLUS : "+" >}TOKEN :{  < POWER : "^" >}TOKEN :{  < MINUS : "-" >}TOKEN :{  < TIMES : "*" >}TOKEN :{  < DIVIDE : "/" >}TOKEN :{  < LOG : "log" >}TOKEN :{  < FACULTY : "!" >}TOKEN :{  < OPEN_PAR : "(" >}TOKEN :{  < CLOSE_PAR : ")" >}TOKEN :{  < COMPARISON : ([ "<", ">", "=", "!" ])? [ "<", ">", "=" ] >}TOKEN :{  < EOL :    "\n"  | "\r" >}public ASTNode parse(MathContainer container) :{  ASTNode node = null;  this.container = container;}{  node = Expression()  {    return node;  }}private ASTNode Expression() :{  ASTNode value = null;}{  value = TermLvl1()  (    < EOF >  | < EOL >  )  {    return value;  }}private ASTNode TermLvl3() :{  ASTNode rightChild;  ASTNode leftChild;  ASTNode node = null;}{  leftChild = Primary()  (    < POWER > rightChild = Primary()    {      node = new ASTNode(ASTNode.Type.POWER, container);      node.addChild(leftChild);      node.addChild(rightChild);      leftChild = node;    }  )*  {    return leftChild;  }}private ASTNode TermLvl2() :{  ASTNode rightChild;  ASTNode leftChild;  ASTNode node = null;}{  leftChild = TermLvl3()  (    < TIMES > rightChild = TermLvl3()    {      node = new ASTNode('*', container);      node.addChild(leftChild);      node.addChild(rightChild);      leftChild = node;    }  | < DIVIDE > rightChild = TermLvl3()    {      if (leftChild.isInteger() && rightChild.isInteger())      {        node = new ASTNode(container);        node.setValue(leftChild.getInteger(), rightChild.getInteger());        leftChild = node;      }      else      {        node = new ASTNode('/', container);        node.addChild(leftChild);        node.addChild(rightChild);        leftChild = node;      }    }  | < LOG > rightChild = TermLvl3()    {      node = new ASTNode(ASTNode.Type.FUNCTION_TAN, container);      node.addChild(leftChild);      node.addChild(rightChild);      leftChild = node;    }  )*  {    return leftChild;  }}private ASTNode TermLvl1() :{  ASTNode rightChild;  ASTNode leftChild;  ASTNode node = null;  Token t;  String s;}{  leftChild = TermLvl2()  (    < PLUS > rightChild = TermLvl2()    {      node = new ASTNode('+', container);      node.addChild(leftChild);      node.addChild(rightChild);      leftChild = node;    }  | < MINUS > rightChild = TermLvl2()    {      node = new ASTNode('-', container);      node.addChild(leftChild);      node.addChild(rightChild);      leftChild = node;    }  | t = < COMPARISON > rightChild = TermLvl2()    {      s = t.image;      Type type = null;      if (s.equalsIgnoreCase("<"))      {        type = ASTNode.Type.RELATIONAL_LT;      }      else if (s.equalsIgnoreCase(">"))      {        type = ASTNode.Type.RELATIONAL_GT;      }      else if (s.equalsIgnoreCase("=="))      {        type = ASTNode.Type.RELATIONAL_EQ;      }      else if (s.equalsIgnoreCase("!="))      {        type = ASTNode.Type.RELATIONAL_NEQ;      }      else if (s.equalsIgnoreCase(">="))      {        type = ASTNode.Type.RELATIONAL_GEQ;      }      else if (s.equalsIgnoreCase("<="))      {        type = ASTNode.Type.RELATIONAL_LEQ;      }      node.setType(type);      node.addChild(leftChild);      node.addChild(rightChild);      leftChild = node;    }  )*  {    return leftChild;  }}/**
 * Javadoc test
 * < table >
 * < tr ><th > Symbol </th ><th > Interpretation</th ></tr >
 * < tr ><td > acos   </td ><td > arccos </td ></tr >
 * < /table >
 */private ASTNode Primary() throws NumberFormatException :{  Token t;  double d;  int i;  ASTNode node = new ASTNode(container);  ASTNode child, furtherChild;  String s;  String vals [ ];  ArrayList < ASTNode > arguments = new ArrayList < ASTNode > ();}{  t = < NUMBER >  {    d = Double.parseDouble(t.image);    node.setValue(d);    return node;  }| t = < INTEGER >  {    i = Integer.parseInt(t.image);    node.setValue(i);    return node;  }| t = < EXPNUMBER >  {    s = t.image;    vals = s.toLowerCase().split("e");    if (vals [ 1 ].startsWith("+"))    {      i = Integer.parseInt(vals [ 1 ].substring(1));    }    else    {      i = Integer.parseInt(vals [ 1 ]);    }    node.setValue(Double.parseDouble(vals [ 0 ]), i);    return node;  }| LOOKAHEAD(2)  t = < STRING > < OPEN_PAR > child = TermLvl1()  (    < SLPITTER > furtherChild = TermLvl1()    {      arguments.add(furtherChild);    }  )*  < CLOSE_PAR >  {    s = t.image;    Type type = null;    if (s.equalsIgnoreCase("abs"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_ABS;      node.addChild(child);    }    else if (s.equalsIgnoreCase("sin"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_SIN;      node.addChild(child);    }    else if (s.equalsIgnoreCase("cos"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_COS;      node.addChild(child);    }    else if (s.equalsIgnoreCase("tan"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_TAN;      node.addChild(child);    }    else if (s.equalsIgnoreCase("asin"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_ARCSIN;      node.addChild(child);    }    else if (s.equalsIgnoreCase("acos"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_ARCCOS;      node.addChild(child);    }    else if (s.equalsIgnoreCase("accosh"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_ARCCOSH;      node.addChild(child);    }    else if (s.equalsIgnoreCase("accot"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_ARCCOT;      node.addChild(child);    }    else if (s.equalsIgnoreCase("accoth"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_ARCCOTH;      node.addChild(child);    }    else if (s.equalsIgnoreCase("accsc"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_ARCCSC;      node.addChild(child);    }    else if (s.equalsIgnoreCase("accsch"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_ARCCSCH;      node.addChild(child);    }    else if (s.equalsIgnoreCase("acsec"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_ARCSEC;      node.addChild(child);    }    else if (s.equalsIgnoreCase("acsech"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_ARCSECH;      node.addChild(child);    }    else if (s.equalsIgnoreCase("acsinh"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_ARCSINH;      node.addChild(child);    }    else if (s.equalsIgnoreCase("actanh"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_ARCTANH;      node.addChild(child);    }    else if (s.equalsIgnoreCase("cosh"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_COSH;      node.addChild(child);    }    else if (s.equalsIgnoreCase("cot"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_COT;      node.addChild(child);    }    else if (s.equalsIgnoreCase("coth"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_COTH;      node.addChild(child);    }    else if (s.equalsIgnoreCase("csc"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_CSC;      node.addChild(child);    }    else if (s.equalsIgnoreCase("csch"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_CSCH;      node.addChild(child);    }    else if (s.equalsIgnoreCase("atan"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_ARCTAN;      node.addChild(child);    }    else if (s.equalsIgnoreCase("ceil"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_CEILING;      node.addChild(child);    }    else if (s.equalsIgnoreCase("floor"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_FLOOR;      node.addChild(child);    }    else if (s.equalsIgnoreCase("log"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_LN;      node.addChild(child);    }    else if (s.equalsIgnoreCase("log10"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_LOG;      node.addChild(child);    }    else if (s.equalsIgnoreCase("pow"))    {      checkSize(arguments, 1);      type = ASTNode.Type.FUNCTION_POWER;      node.addChild(child);    }    else if (s.equalsIgnoreCase("sqr"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_POWER;      node.addChild(child);      node.addChild(new ASTNode(2, container));    }    else if (s.equalsIgnoreCase("sqrt"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_ROOT;      node.addChild(new ASTNode(2, container));      node.addChild(child);    }    else if (s.equalsIgnoreCase("exp"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_EXP;      node.addChild(child);    }    else if (s.equalsIgnoreCase("fac"))    {      checkSize(arguments, 0);      type = ASTNode.Type.FUNCTION_FACTORIAL;      node.addChild(child);    }    node.setType(type);    for (ASTNode argument : arguments)    {      node.addChild(argument);    }    return node;  }| < OPEN_PAR > node = TermLvl1() < CLOSE_PAR >  {    return node;  }| < MINUS > node = Primary()  {    ASTNode uiMinus = new ASTNode('-', container);    uiMinus.addChild(node);    return uiMinus;  }| t = < STRING >  {    s = t.image;    node = new ASTNode(s, container);    return node;  }}
