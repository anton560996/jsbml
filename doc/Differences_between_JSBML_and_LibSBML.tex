\documentclass[
  BCOR12mm,
  letterpaper,
  11pt,
  headsepline,
  pointlessnumbers,
  tablecaptionabove,
  onelinecaption,
  headinclude,
  appendixprefix,
  idxtotoc,
  bibtotoc,
  twoside,
  titlepage
]{scrartcl}

% Fonts
\usepackage{mathptmx} % Times font in main text and mathematical formulas
\usepackage{wasysym}  % Contains several special symbols
\usepackage{pifont}   % Enables Zapf dingbats (special symbols)
\usepackage[scaled=.95]{helvet} % Sans serif font to be used

% Page style

\usepackage[automark]{scrpage2}
\usepackage[paper=letterpaper, centering]{geometry}
\usepackage{caption2}

% Language definition
\usepackage[english]{babel}
\usepackage{varioref} % better references with \vref
\usepackage{natbib}   % nice citeation

% Figures
\usepackage{graphicx}
\usepackage{sidecap}
\usepackage{rotating}    % Allows setting sideways tables and figures, and to
                                        % rotate text.

% Some color in the document
\usepackage{color}

% Source code and pseudo code
\usepackage{listings}    % Source code listing support
\usepackage{algorithm}
\usepackage{algorithmic} % Algorithmen im Pseudo-Code,

\usepackage[unicode, breaklinks]{hyperref}
\usepackage[htt]{hyphenat}

% some nice colors
\definecolor{royalblue}{cmyk}{.93, .79, 0, 0}
\definecolor{lightblue}{cmyk}{.10, .017, 0, 0}
\definecolor{darkgreen}{rgb}{0,.7,0}
\definecolor{darkred}{rgb}{.7,0,0}
\definecolor{lightgray}{gray}{0.97}

% Style definitions

\selectlanguage{english}
\addtokomafont{sectioning}{\color{royalblue}}
\pagestyle{scrheadings}
\ifoot{\includegraphics[width=50pt]{logo/JSBML_shaddow.pdf}}

\hypersetup{
              bookmarks={true},
              bookmarksopen={true},
              bookmarksopenlevel={0},
              bookmarksnumbered={true},
              breaklinks={true},
              colorlinks={false},
              pdfpagemode={UseOutlines},
              pdftitle={A short description of the main differences between
              JSBML and LibSBML},
              pdfauthor={Andreas Dr\"ager, Nicolas Rodriguez, Alexander
              D\"orr, Marine Dumousseau, Clemens Wrzodek,
%               Nicolas Le Nov{\`e}re,
%               Andreas Zell,
              Michael Hucka},
              pdfsubject={Software guide},
              pdfkeywords={JSBML} {LibSBML} {Java} {SBML} {API} {LaTeX},
              pdfview={FitV},
              pdftex,
              pdffitwindow={true},
              pdfstartview={FitV},
              pdfnewwindow={false},
              pdfdisplaydoctitle={true},
              pdfhighlight={/P},
              plainpages={false},
              unicode={true},
              urlcolor={blue}
}

% for index
\usepackage{makeidx}
\makeindex

\lstset{language=Java,
captionpos=b,
basicstyle=\footnotesize\ttfamily\bfseries,
stringstyle=\color{darkred}\footnotesize\ttfamily,
keywordstyle=\color{royalblue}\bfseries\ttfamily,
ndkeywordstyle=\color{darkgreen},
numbers=left,
numberstyle=\footnotesize,
% backgroundcolor=\color{lightgray},
breaklines=true,
tabsize=2,
frame=single,
breakatwhitespace=true
% framexleftmargin=5mm,
% rulesepcolor=\color{lightgray}
% frameround=ttff
}

\hyphenation{
Cell-De-sig-n-er
}

\title{A short description of the main differences between JSBML and LibSBML}
\author{Andreas Dr\"ager\thanks{Center for Bioinformatics Tuebingen, University
of Tuebingen, T\"ubingen, Germany}\and%
Nicolas Rodriguez\thanks{European Bioinformatics Institute, Wellcome Trust
Genome Campus, Hinxton, Cambridge, UK}\and%
Alexander D\"orr\footnotemark[1]\and%
Marine Dumousseau\footnotemark[2]\and%
Clemens Wrzodek\footnotemark[1]\and%
% Nicolas Le Nov{\`e}re\footnotemark[2]\and%
% Andreas Zell\footnotemark[1]\and%
Michael Hucka\thanks{Beckman Institute BNMC, California Institute of Technology,
Pasadena, CA, USA}}
\date{\today}
\publishers{\includegraphics[width=100pt]{logo/JSBML_shaddow.pdf}}

\begin{document}

\maketitle
\tableofcontents

\begin{abstract}
Although the libraries JSBML and LibSBML for working with files and data
structures defined in the standard SBML (Systems Biology Markup Language) are
very similar and share a common scope, users should be informed about their
major differences to switch from one library from the other one more easily. To
this end, the document at hand gives a brief overview of the main differences
between the Java\texttrademark{} application programming interfaces of both
libraries.

In addition, JSBML can be used as a communication layer between the widely
spread application CellDesigner and an application that works with JSBML as its
internal data structure. This document gives an example that demonstrates how to
convert between CellDesigner's plug-in data structures and JSBML objects.

In the same way, it is possible to inter-convert between data structures obtained
from LibSBML and JSBML data structures. \textcolor{red}{This document also
provides an example of how to read SBML files with LibSBML, to turn them into
JSBML data structures, manipulate them and to turn it back for writing into the
LibSBML format.}

Furthermore, JSBML provides a compatibility module, whose member classes show
an identical type declaration as defined in LibSBML. In this way, the
compatibility module facilitates switching from LibSBML to JSBML and vice versa
by simply exchanging the included JAR file in the project. \textcolor{red}{As for
the other two modules, this document also gives an example for the usage of the
compatibility module.}
\end{abstract}

\section{An extended type hierarchy}

Whenever multiple elements defined in at least one of the SBML\index{SBML} specifications \citep{Hucka2003, Hucka2008, Hucka2010a} share some
attributes, JSBML\index{JSBML!Type hierarchy} provides a common super class or at least a common interface
that gathers methods for manipulation of the shared properties. In this way, the
type hierarchy of JSBML\index{Application programming interface!JSBML} has become more complex (see
Figs.~\vrefrange{fig:TypeHierarchy}{fig:MathContainerHierarchy}).
\begin{sidewaysfigure}[htbp]
\centering
\includegraphics[width=\textwidth]{img/FullTypeHierarchy}
\caption[The type hierarchy in JSBML]{The type hierarchy of the main SBML
constructs in JSBML}
\label{fig:TypeHierarchy}
\end{sidewaysfigure}
\begin{figure}[htb]
 \centering
 \includegraphics[width=\textwidth,bb=0 0 1001 568,keepaspectratio=true]{%
img/SBase}
 % SBase.pdf: 1001x568 pixel, 72dpi, 35.31x20.04 cm, bb=0 0 1001 568
 \caption[The interface \texttt{SBase}]{The interface \texttt{SBase}, adapted
from \citep{Draeger2011}. This figure displays the most important top-level data
structures of JSBML with main focus on the differences to LibSBML. All other
data types that represent SBML constructs in JSBML extend either one of the two
abstract classes \texttt{AbstractSBase} or \texttt{AbstractNamedSBase}. The
class \texttt{SBO} parses the ontology file provided on the SBO web
site (\url{http://www.ebi.ac.uk/sbo/main/}) in OBO format (Open
Biomedical Ontologies) using a parser provided by the BioJava project
\citep{Holland2008}. For the sake of a clear arrangement, this figure omits
methods, fields and other properties.}
 \label{fig:SBase}
\end{figure}
\begin{figure}[htb]
 \centering
 \includegraphics[width=.8\textwidth,bb=0 0 557 396,keepaspectratio=true]{%
img/MathContainerClass}
 % MathContainerClass.pdf: 557x396 pixel, 72dpi, 19.65x13.97 cm, bb=0 0 557 396
 \caption[Abstract syntax trees]{Abstract syntax trees, adapted from
 \citep{Draeger2011}. The class \texttt{AbstractMathContainer} severs as the
 super class for several model components in JSBML. It provides methods to
 manipulate and access an instance  of \texttt{ASTNode}, which can be converted
 to or read from \texttt{C}-like formula \texttt{String}s. Internally,
 \texttt{AbstractMathContainer}s only deal with instances of \texttt{ASTNode}.
 It should be noted that these abstract syntax trees do not implement the
 \texttt{SBase} interface, but also implement the Java interfaces
 \texttt{Cloneable}, \texttt{Serializable}, and \texttt{TreeNode}. In this
 figure, the inheritance relationship between
 \texttt{SBase} and \texttt{Cloneable} as well as between \texttt{SBase} and
 \texttt{Serializable} has been omitted for the sake of simplicity.}
 \label{fig:MathContainer}
\end{figure}
\begin{figure}[p]
 \centering
 \includegraphics[width=\textwidth,bb=0 0 596 587,keepaspectratio=true]{%
img/Symbol}
 % Symbol.pdf: 596x587 pixel, 72dpi, 21.03x20.71 cm, bb=0 0 596 587
 \caption[The interface \texttt{Variable}]{The interface \texttt{Variable}, adapted from \citep{Draeger2011}. JSBML refers to those components of a model that may change their value during a simulation as \texttt{Variable}s. The class \texttt{Symbol} serves as the abstract super class for variables that can also be equipped with a unit. Instances of \texttt{Parameter} do not contain any additional field. In \texttt{Species} a Boolean switch decides whether its value is to be interpreted as an initial amount or as an initial concentration. In contrast to \texttt{Variable}s, \texttt{LocalParameter}s represent constant unit-value pairs that can only be accessed within their declaring \texttt{KineticLaw}.}
 \label{fig:Variable}
\end{figure}
\begin{figure}[htb]
 \centering
 \includegraphics[width=\textwidth]{img/MathContainer}
 % MathContainerClass.pdf: 557x396 pixel, 72dpi, 19.65x13.97 cm, bb=0 0 557 396
 \caption[\texttt{MathContainer}]{\texttt{MathContainer}, adapted from \citep{Draeger2011}. Instances of the interface \texttt{MathContainer}, particularly its directly derived class \texttt{AbstractMathContainer} constitute the super class for all elements that store and manipulate mathematical formulas in JSBML, which is done in form of \texttt{ASTNode} objects. These can be evaluated using an implementation of \texttt{ASTNodeCompiler}. Note that some classes that extend \texttt{AbstractMathContainer} do not contain any own fields or methods: \texttt{Delay}, \texttt{Trigger}, \texttt{StoichiometryMath}, and \texttt{AlgebraicRule}.}
 \label{fig:MathContainerHierarchy}
\end{figure}
Just like in LibSBML\index{Application programming interface!LibSBML} \citep{Bornstein2008}, all elements extend the abstract type \texttt{SBase}\index{\texttt{SBase}}, but in
JSBML\index{\texttt{SBase}}, \texttt{SBase} has become an interface. This allows more complex relations
between derived data types. In contrast to LibSBML\index{\texttt{SBase}}, \texttt{SBase} in JSBML\index{\texttt{SBase}}
extends three other interfaces: \texttt{Cloneable}, \texttt{Serializable},
\index{\texttt{Serializable}}
and \texttt{TreeNode}. As all elements defined in JSBML\index{Cloning} override the \texttt{clone()}
method from the class \texttt{java.lang.Object}\index{\texttt{Object}}, all JSBML elements can be deeply
copied and are therefore \emph{cloneable}. By extending the interface
\texttt{Serializable},
\index{\texttt{Serializable}}
it is possible to store JSBML\index{Application programming interface!JSBML} elements in binary form
without explicitly writing it to an SBML file\index{SBML!XML file}. In this way, programs can easily
load and save their in-memory objects or send complex data structures
through a network connection without the need of additional file encoding and
subsequent parsing. The third interface, \texttt{TreeNode} is actually defined in
Java's \texttt{swing}\index{Graphical user interface!\texttt{swing}} package, but defines a data type independent of any
graphical information. It basically defines recursive methods on hierarchically
structured data types, such as iteration over all of its successors. In this
way, all instances of JSBML's\index{\texttt{SBase}} \texttt{SBase} interface can be directly passed to
the \texttt{swing}\index{Graphical user interface!\texttt{swing}} class \texttt{JTree}\index{Graphical user interface!\texttt{JTree}} and hence be easily visualized.
Listing~\vref{lst:Visualization} demonstrates in a simple code example how to
parse an SBML file\index{SBML!XML file} and to immediately display its content on a \texttt{JFrame}\index{Graphical user interface!\texttt{JFrame}}.
\lstinputlisting[language=Java,float,caption={Parsing and visualizing the
content of an SBML file},label=lst:Visualization]{posters/2010_ICSB_and_COMBINE/org/sbml/gui/JSBMLvisualizer.java}
Fig.~\vref{fig:Visualization} shows an example output when applying the program
from Listing~\vref{lst:Visualization} to SBML test model \texttt{case00026}\index{SBML!Test cases}.
\begin{SCfigure}[][t]
\includegraphics[width=.35\textwidth]{posters/2010_ICSB_and_COMBINE/JSBMLvisualizerTransparent}
\caption[Tree representation of an SBML file]{A tree representation of the
content of SBML test model \texttt{case00026}}
\label{fig:Visualization}
\end{SCfigure}
The \texttt{ASTNode} class in JSBML\index{\texttt{ASTNode}} also implements all these three interfaces and
can hence be cloned, serialized, and visualized in the same way.


\subsection{The \texttt{Assignment} class}

JSBML\index{JSBML!\texttt{Assignment}} unifies all those elements that assign values to some other
\texttt{SBase}\index{\texttt{SBase}} in SBML\index{SBML} \citep{M.Hucka03012003} under the interface \texttt{Assignment}. This interface
uses the term \emph{variable} for the element whose value is to be changed depending on some mathematical expression that is also present in the \texttt{Assignment}
(because \texttt{Assignment} extends the interface \texttt{MathContainer}\index{JSBML!\texttt{MathContainer}}). Therefore,
an Assignment contains methods such as \texttt{set}-/\texttt{getVariable(Variable v)} and also \texttt{isSetVariable()} as well as
\texttt{unsetVariable()}. In addition to that, JSBML also provides the method \texttt{set}-/\texttt{getSymbol(String symbol)} in the \texttt{InitialAssignment}
\index{\texttt{InitialAssignment}}
class to make sure that switching from LibSBML\index{\texttt{InitialAssignment}} to JSBML is quite smoothly.
However, the preferred way in JSBML\index{JSBML!\texttt{Variable}} is to apply the methods
\texttt{setVariable} either with \texttt{String}\index{\texttt{String}} or \texttt{Variable} instances as arguments.

\subsection{The \texttt{MathContainer} interface}

This interface gathers all those elements that may contain mathematical
expressions encoded in abstract syntax trees (instances of \texttt{ASTNode}\index{\texttt{ASTNode}}).
The abstract class \texttt{AbstractMathContainer}\index{JSBML!\texttt{MathContainer}} serves as actual super class
for most of the derived types.


\section{Differences in the abstract programming interface}

JSBML strives to attain an almost complete compatibility to LibSBML. However,
the differences in the programming languages \texttt{C} and Java\texttrademark{}
lead to the necessity of introducing some differences. In some cases, a direct
``translation" from \texttt{C} code to Java would not be very elegant. JSBML
wants to provide a Java API\index{Application programming interface!Java}, whose classes and methods are structured and named
and behave like classes and methods in other Java libraries. In this section, we
will discuss the most important differences in the APIs of JSBML\index{Application programming interface!JSBML} and LibSBML\index{Application programming interface!LibSBML}.


\subsection{Abstract syntax trees}

Both libraries define a class \texttt{ASTNode}\index{\texttt{ASTNode}} for in-memory manipulation and
evaluation of abstract syntax trees that represent mathematical formulas and
equations. These can either be parsed from a representation in \texttt{C}
language-like \texttt{String}s\texttt{String}\index{\texttt{String}}, or from a MathML\index{MathML} representation. The JSBML\index{\texttt{ASTNode}}
\texttt{ASTNode} provides various methods to transform these trees to other
formats, for instance, \LaTeX{}\index{\LaTeX} \texttt{String}s. In JSBML, several static
methods allow easy creation of new syntax trees, for instance, the following
code
\begin{lstlisting}
ASTNode myNode = ASTNode.plus(myLeftAstNode, myRightASTNode);
\end{lstlisting}
creates a new instance of \texttt{ASTNode} which represents the sum of the two
other \texttt{ASTNode}s. In this way, even complex trees can be easily
manipulated.

\subsection{The \texttt{ASTNodeCompiler} class}

This interface allows users to create customized interpreters for the
content of mathematical equations encoded in abstract syntax trees. It
is directly and recursively called from the \texttt{ASTNode} class and returns
an \texttt{ASTNodeValue}\index{\texttt{ASTNode}!\texttt{ASTNodeValue}}\index{\texttt{ASTNode}!\texttt{ASTNodeCompiler}} object, which wraps the possible evaluation results of
the interpretation. JSBML\index{\texttt{ASTNode}} already provides several implementations of
this interface, for instance, \texttt{ASTNode} objects can be directly translated
to \LaTeX{}\index{\LaTeX} or MathML\index{MathML} for further processing.

\subsection{Cloning when adding child nodes}

When adding elements such as a \texttt{Species}\index{Species!\texttt{Species}} to a \texttt{Model}\index{Model!!\texttt{Model}}, LibSBML\index{Cloning} will
clone the object and add the clone to the \texttt{Model}. In contrast, JSBML\index{Cloning} does
not automatically perform cloning. The advantage is that modifications on the
object belonging to the original pointer will also propagate to the element
added to the \texttt{Model}. Furthermore, this is more efficient with respect to
the run time and also more intuitive. If cloning is necessary, users should call
the \texttt{clone()} method manually. Since all instances of \texttt{SBase}\index{\texttt{SBase}} and also
\texttt{Annotation}\index{Annotation}, \texttt{ASTNode}\index{\texttt{ASTNode}}, \texttt{CVTerm}\index{Annotation!\texttt{CVTerm}}, and \texttt{History}\index{Annotation!\texttt{History}} implement
the interface \texttt{Cloneable}\index{Cloning} (see Fig.~\vref{fig:TypeHierarchy}), all these
elements can be naturally cloned. However, when cloning an object in
JSBML\index{Cloning}, such as an \texttt{AbstractNamedSBase}\index{\texttt{SBase}!\texttt{AbstractNamedSBase}}, all children of this element will recursively be
cloned before adding them to the new element. This is necessary, because the data
structures specified in SBML\index{SBML!Hierarchical structure} define a tree, in
which each element has exactly one parental node.


\subsection{Deprecation}

The intension of JSBML\index{JSBML!Deprication} is to provide a Java library for
the latest specification of SBML\index{SBML}. Hence, JSBML provides methods and
classes to cover earlier releases of SBML as well, but these are often marked
as being deprecated to avoid creating models that refer to these 
elements.

\subsection{Exceptions}

Generally, JSBML\index{Exception} throws more exceptions than LibSBML\index{Exception!Error codes}, whose methods often return error codes instead. This behavior helps
programmers and users to avoid creating invalid SBML data structures already
when dealing with these in memory. Examples are the \texttt{ParseException}
\index{Exception!\texttt{ParseException}} that
may be thrown if a given formula cannot be parsed properly into an
\texttt{ASTNode}\index{\texttt{ASTNode}} data structure, or \texttt{InvalidArgumentException}s
\index{Exception!\texttt{InvalidArgumentException}} if inappropriate values are passed to methods. For instance,
\begin{itemize}
 \item an object representing
a constant such as a \texttt{Parameter}
\index{\texttt{Parameter}}
whose constant attribute has been set to
\texttt{true} cannot be used as the \texttt{Variable}\index{JSBML!\texttt{Variable}} element in an
\texttt{Assignment}.
 \item Another example is the \texttt{InvalidArgumentException} that
is thrown when trying to set an invalid identifier \texttt{String} for an instance of \texttt{AbstractNamedSBase}\index{\texttt{SBase}!\texttt{AbstractNamedSBase}}.
 \item An instance of \texttt{Priority}\index{Event!\texttt{Priority}} can only be assigned to an \texttt{Event}s\index{Event!\texttt{Event}} if its \texttt{level}\index{SBML!Level~3} attribute has at least been set to three.
\end{itemize}
Hence, you have to be aware of potential
exceptions and errors when using JSBML\index{Exception}, on the other hand this will
prevent you from doing obvious mistakes.


\subsection{Model history}

In earlier versions of SBML\index{SBML} only the model itself could be associated
with a history, i.e., a description about the person(s) who build this model,
including names, e-mail addresses, modification and creation dates. Nowadays, it
has become possible to annotate each individual construct of an SBML model with
such a history. This is reflected by naming the corresponding object
\texttt{History}\index{Annotation!\texttt{History}}
in JSBML\index{Annotation!\texttt{ModelHistory}}, whereas it is still called
\texttt{ModelHistory} in LibSBML\index{Annotation!\texttt{ModelHistory}}. Hence, all
instances of \texttt{SBase}\index{\texttt{SBase}} in JSBML\index{JSBML!
\texttt{ModelHistory}} contain methods do access and manipulate its
\texttt{History}. Furthermore, you will not find the classes
\texttt{ModelCreator}
and \texttt{ModelCreatorList} because JSBML\index{Annotation!\texttt{ModelCreator}}
gathers its \texttt{Creator} objects
in a generic \texttt{List<Creator>} in the \texttt{History}\index{Annotation!\texttt{History}}.
 

\subsection{The classes \texttt{libSBML} and \texttt{JSBML}}

There is no class \texttt{libSBML} because this library is called
\texttt{JSBML}\index{\texttt{libSBML}}\index{\texttt{libSBML}}. You can therefore only find a class \texttt{JSBML}\index{JSBML!\texttt{JSBML}}. This class
provides some similar methods as the \texttt{libSBML} class in LibSBML, such as
\texttt{getJSBMLDottedVersion()}
\index{JSBML!Version} to obtain the current
version of the JSBML library. However, many other methods that you might expect
to find there, if you are used to LibSBML, are located in the actual classes that
are related with the function. For instance, the method to convert between a
\texttt{String}\index{\texttt{String}} and
a corresponding \texttt{Unit.Kind}
\index{Unit!\texttt{Unit.Kind}} can be done
by using the method
\begin{lstlisting}
Unit.Kind.valueOf(myString);
\end{lstlisting}
In a similar way, the \texttt{ASTNode}\index{\texttt{ASTNode}} class provides a method to parse
\texttt{C}-like
formula \texttt{String}s according to the specification of SBML Level 1\index{SBML!Level~1}
\citep{Hucka2003} into an abstract syntax tree\index{\texttt{ASTNode}}. Therefore, in contrast to the
\texttt{libSBML} class, the class \texttt{JSBML}\index{JSBML!\texttt{JSBML}} contains only a few methods.


\subsection{Replacement of the interface \texttt{libSBMConstants} by Java \texttt{enum}s}

You won't find a corresponding implementation of this interface in 
JSBML. The reason is that the JSBML team decided to encode constants using the
Java construct \texttt{enum}. For instance, all the fields starting with the
prefix \texttt{AST\_TYPE\_*}
\index{\texttt{ASTNode}!\texttt{AST\_TYPE\_*}} have a
corresponding field in the \texttt{ASTNode} class itself. There you can find the
\texttt{Type}
\index{\texttt{ASTNode}!\texttt{ASTNode.Type}} enum.
Instead of typing \texttt{libSBMLConstants.AST\_TYPE\_PLUS}, you would therefore
type \texttt{ASTNode.Type.PLUS}.

The same holds true for \texttt{Unit.Kind.*} corresponding to the
\texttt{libSBMLConstants.UNIT\_KIND\_*}
\index{Unit!\texttt{UNIT\_KIND\_*}} fields.


\subsection{Various types of \texttt{ListOf*} classes}

In JSBML the \texttt{ListOf*}
\index{\texttt{ListOf*}}
objects do not offer a method
\texttt{get(String id)} because their generic implementation 
\texttt{ListOf<? extends SBase>} excepts also elements that do
not necessarily have an identifier. Only instances of \texttt{NamedSBase}\index{\texttt{SBase}!\texttt{NamedSBase}} may have
the fields identifier and name set. Hence, generally, the \texttt{ListOf} class
cannot assume these fields to be present. To query an instance of \texttt{ListOf}
in JSBML for names or identifiers or both, you can apply the following filter:
\begin{lstlisting}
NamedSBase nsb = myList.firstHit(new NameFilter(identifier));
\end{lstlisting}
This will give you the first element in the list with the given identifier.
Various filters are already implemented, but you can easily add your 
customized filter. To this end, you only have to implement the \texttt{Filter}
\index{Application programming interface!JSBML!\texttt{ListOf*}!\texttt{Filter}}
interface in \texttt{org.sbml.jsbml.util.filters}\index{\texttt{ListOf*}!\texttt{Filter}}. There you can also find an
\texttt{OrFilter} and an \texttt{AndFilter}, which take as arguments multiple other
filters. With the \texttt{SBOFilter} you can query for certain SBO  annotations \citep{Novere2006,Novere2006b}\index{Annotation!SBO} in
your list, whereas the \texttt{CVTermFilter} helps you to identify \texttt{SBase}
\index{\texttt{SBase}}
instances with a desired MIRIAM (Minimal Information Required In the Annotation of Models) annotation\index{Annotation} \citep{Novere2005}. For instances of
\texttt{ListOf<Species>} you can apply the \texttt{BoundaryConditionFilter} to look
for those species\index{Species!Boundary condition} that operate on the boundary of the reaction system.


\subsection{Units}

Since SBML Level 3\index{SBML!Level~3} \citep{Hucka2010a} the data type of the exponent attribute in the \texttt{Unit}
class has been changed from \texttt{int} to \texttt{double} values.
JSBML\index{Unit}
\index{Application programming interface!JSBML!Units!\texttt{getExponent()}}
\index{Application programming interface!JSBML!Units!\texttt{getExponentAsDouble()}}
reflects this in the method \texttt{getExponent()} by returning \texttt{double}
values only. For a better compatibility with LibSBML
\index{Application programming interface!LibSBML!Units!\texttt{getExponentAsDouble()}}
\index{Application programming interface!LibSBML!Units!\texttt{getExponent()}}, whose corresponding method still
returns \texttt{int} values, JSBML also provides the method
\texttt{getExponentAsDouble()}. This method returns the value from the
\texttt{getExponent()} method and is therefore absolutely redundant.

\subsection{Unit Definitions}

\subsubsection{Predefined unit definitions}

A model in JSBML\index{Application programming interface!JSBML!Units!Predefined units} always also contains all predefined units in the model
if there are any, i.e., for models encoded of SBML versions before Level
3\index{SBML!Level~3}. These can be accessed from an instance of model by calling the method
\texttt{getPredefinedUnit(String unit)}.

MIRIAM annotations\index{Annotation!MIRIAM} \citep{Novere2005} have become an integral part of SBML models
since Level 2 Version 2\index{SBML!Level~2 Version~2}. Recently, the Unit
Ontology\footnote{\url{http://www.obofoundry.org/cgi-bin/detail.cgi?id=unit}}
\index{Annotation!Unit ontology}
(UO) has been included in the set of supported ontology and online resources of
MIRIAM. Since all the predefined units in SBML have corresponding entries in the
UO, JSBML\index{Unit!MIRIAM annotation} automatically equips those predefined units with the correct MIRIAM
URI in form of a controlled vocabulary term (\texttt{CVTerm}) if the
Level/Version combination of the model supports MIRIAM annotations.

Note that the \texttt{enum} \texttt{Unit.Kind}
\index{Unit!\texttt{Unit.Kind}} also provides
methods to directly
obtain the entry from the UO that corresponds to a certain unit kind and also to
generate MIRIAM URIs accordingly. In this way, JSBML facilitates the annotation
of user-defined units and unit definitions with MIRIAM-compliant\index{Annotation!MIRIAM} information.

\subsubsection{Access to the units of an element}

In JSBML, all SBML elements that can be associated with some unit implement the
interface \texttt{SBaseWithUnit}\index{\texttt{SBase}!\texttt{SBaseWithUnit}}. This interface provides methods for direct
access to an object representing their unit. Currently, the following elements
implement this interface:
\begin{itemize}
 \item \texttt{AbstractNamedSBaseWithUnit}
 \item \texttt{ExplicitRule}\index{Rule!\texttt{ExplicitRule}}
 \item \texttt{KineticLaw}
 \index{\texttt{KineticLaw}}
\end{itemize}
Fig.~\vref{fig:TypeHierarchy} provides a better overview about the relationships
between all the classes explained here. Note that
\texttt{AbstractNamedSBaseWithUnit} serves as the abstract super class for
\texttt{Event}\index{Event} and \texttt{QuantityWithUnit}\index{JSBML!\texttt{QuantityWithUnit}}. In \texttt{Event}, all methods
to deal with units are already deprecated because only in SBML Level 1 Versions 1
and 2\index{SBML!Level~1} \citep{Hucka2003} \texttt{Event}s could be explicitly equipped with units.
The same holds true for instances of \texttt{ExplicitRule}
\index{Rule!\texttt{ExplicitRule}}
and \texttt{KineticLaw},
\index{\texttt{KineticLaw}}
which both can only explicitly be populated with units for
SBML in Level 1, Version 1 and 2\index{SBML!Level~1}. In contrast, \texttt{QuantityWithUnit}\index{JSBML!\texttt{QuantityWithUnit}} serves
as the abstract super class for \texttt{LocalParameter}\index{\texttt{LocalParameter}} and \texttt{Symbol}\index{JSBML!\texttt{Symbol}},
which is then again the super type of \texttt{Compartment}\index{\texttt{Compartment}}, \texttt{Species}\index{Species}, and (global) \texttt{Parameter}\index{\texttt{Parameter}}.

With \texttt{SBaseWithUnit}\index{\texttt{SBase}!\texttt{SBaseWithUnit}} being a subtype of \texttt{SBaseWithDerivedUnit}\index{\texttt{SBase}!\texttt{SBaseWithDerivedUnit}}
users can access the units of such an element in two different ways:
\begin{description}
 \item[\texttt{getUnit()}] This method returns the \texttt{String}\index{\texttt{String}} of the unit
 kind or the unit definition in the model\index{Model}
 that has been directly set by the user
 during the life time of the element. If nothing has been declared, an empty
 \texttt{String} will be delivered.
 \item[\texttt{getDerivedUnit()}] This method gives either the same result as
 \index{Application programming interface!JSBML!Units!Derived Unit}
 \texttt{getUnit()} if some unit has been declared explicitly, or it returns the
 predefined unit of the element for the given SBML Level/Version combination.
 Only if neither a user-defined nor a predefined unit is available, this method
 returns an empty \texttt{String}\index{\texttt{String}}.
\end{description}
Both methods have corresponding methods to directly obtain an instance of
\texttt{UnitDefinition}
\index{Application programming interface!JSBML!Units!\texttt{UnitDefinition}}
for convenience.

However, care must be taken when obtaining an instance of \texttt{UnitDefinition}
\index{Application programming interface!JSBML!Units!\texttt{UnitDefinition}}
from one of the classes implementing \texttt{SBaseWithUnit}\index{\texttt{SBase}!\texttt{SBaseWithUnit}}
because it might happen that the model\index{Model} containing this \texttt{SBaseWithUnit}
\index{\texttt{SBase}!\texttt{SBaseWithUnit}}
does actually not contain the required instance of \texttt{UnitDefinition} and
the method returns a \texttt{UnitDefinition} that has just been created for
convenience from the information provided by the class. It might therefore be
useful to either check if the \texttt{Model}\index{Model!\texttt{Model}} contains this
\texttt{UnitDefinition}
\index{Application programming interface!JSBML!Units!\texttt{UnitDefinition}}
or to add it to the \texttt{Model}\index{Model!\texttt{Model}}.

In case of \texttt{KineticLaw}
\index{\texttt{KineticLaw}}
it is even more difficult, because
SBML Level 1\index{SBML!Level~1} allows to separately set the substance unit and the time unit of
the element. To unify the API\index{Application programming interface!JSBML}, we decided to also provide methods that allow
the user to simply pass one \texttt{UnitDefinition}
\index{Application programming interface!JSBML!Units!\texttt{UnitDefinition}}
or its identifier to
\texttt{KineticLaw}.
\index{\texttt{KineticLaw}}
These methods then try to guess if a substance unit or time
unit is given. Furthermore, it is possible to pass a \texttt{UnitDefinition}
representing a variant of substance per time directly. In this case, the
\texttt{KineticLaw}
\index{\texttt{KineticLaw}}
will memorize a direct link to this \texttt{UnitDefinition}
in the model\index{Model} and also try to save separate links to the time unit and the
substance unit. However, this may cause a problem if the containing
\texttt{Model}\index{Model!\texttt{Model}} does not contain separate \texttt{UnitDefinition}s for both
entries.

Generally, this approach provides a more general way to access and to manipulate
units of SBML elements.

\section{Additional features of JSBML}

The JSBML library also provides some features that cannot be found in LibSBML.
This section briefly introduces its most important additional capabilities.

\subsection{Change events and listeners}

JSBML introduces the possibility to listen to change events in the life of an
SBML document. To benefit from this advantage, simply let your class implement
the interface \texttt{SBaseChangedListener}\index{Event!\texttt{SBaseChangedListener}} and add it to the list of listeners in
your instance of \texttt{SBMLDocument}\index{SBML!\texttt{SBMLDocument}}. You only have to implement three methods
\begin{description}
 \item[\texttt{sbaseAdded(SBase sbase)}] This method notifies the listener that the given \texttt{SBase}\index{\texttt{SBase}}
   has just been added to the \texttt{SBMLDocument}
 \item[\texttt{sbaseRemoved(SBase sbase)}] The \texttt{SBase} instance passed to this method is no
   longer part of the \texttt{SBMLDocument} as it has just been removed.
 \item[\texttt{stateChanged(SBaseChangedEvent event)}] This method provides detailed information about some value
   change within the \texttt{SBMLDocument}. The object passed to this method is
   an \texttt{SBaseChangedEvent}\index{Event!\texttt{SBaseChangedEvent}}, which provides information about the \texttt{SBase}\index{\texttt{SBase}}
   that has been changed, its property whose value has been changed (this is a
   \texttt{String}\index{\texttt{String}} representation of the name of the property), along with the
   previous value and the new value.
\end{description}
With the help of these methods, you can keep track of what your
\texttt{SBMLDocument}\index{SBML!\texttt{SBMLDocument}} does at any time. Furthermore, one could consider to make
use of this functionality in a graphical user interface\index{Graphical user interface}, where the user should
be asked if he or she really wants to delete some element or to approve changes
before making these persistent. Another idea of using this, would be to write
log files\index{Logging!Log file} of the model\index{Model} building process automatically.

Note that the class \texttt{SBaseChangedEvent}\index{Event!\texttt{SBaseChangedEvent}} implements the class
\texttt{java.util.EventObject}\index{Event!\texttt{EventObject}} and that the interface
\texttt{SBaseChangedListener}\index{Event!\texttt{SBaseChangedListener}}\index{Event!\texttt{SBaseChangedListener}} extends the interface
\texttt{java.util.EventListener}\index{Event!\texttt{EventListener}}. In this way, the event and listener data
structures fit into the common Java API (Application Programming Interface)\index{Application programming interface!Java} and
allow users also to make use of, e.g., \texttt{EventHandler}s\index{Event!\texttt{EventHandler}} to deal with
changes in a model\index{Model}. It should also be noted that \texttt{SBaseChangedListener}s
only keep track of changes in instances of \texttt{SBase} directly. This means
that changes inside of, e.g., \texttt{CVTerm}\index{Annotation!\texttt{CVTerm}} or \texttt{History}\index{Annotation!\texttt{History}} may not be
traced.

\subsection{Logging functionality}

\textcolor{red}{JSBML provides logging.}
\index{Logging}

\appendix

\section{Frequently Asked Questions (FAQ)}

\begin{description}
  \item[Why does the class \texttt{LocalParameter} not inherit from
  \texttt{Parameter}?]
  \index{\texttt{LocalParameter}}
  \index{\texttt{Parameter}}
The reason is the Boolean attribute \texttt{constant}, which is present in
\texttt{Parameter} and can be set to \texttt{false}. A parameter in the meaning
of SBML is not a constant, it might be some system variable\index{JSBML!\texttt{Variable}} and can therefore
be the subject of \texttt{Rule}s,
\index{Rule}
\texttt{Event}s\index{Event!\texttt{Event}}, \texttt{InitialAssignment}s\index{\texttt{InitialAssignment}}
and so on, i.e., all instances of \texttt{Assignment}\index{JSBML!\texttt{Assignment}}, whereas a
\texttt{LocalParameter} is defined as a constant quantity that never changes its
value during the evaluation of a model\index{Model}. It would therefore only be possible to
let \texttt{Parameter} inherit from \texttt{LocalParameter} but this could lead
to a semantic misinterpretation.
\end{description}

\section{An example of how to turn a JSBML-based application into a CellDesigner
plug-in}

Once an application has been implemented based on JSBML, it can easily be
accessed from CellDesigner's plug-in menu \citep{Funahashi2003}. To this end,
it is necessary to extend two classes that are defined in CellDesigner's plug-in
API (Application Programming Interface)\index{Application programming interface!CellDesigner}. The Listings~\vrefrange{lst:PluginAction}
{lst:Plugin} show a very simple example of how to pass CellDesigner plug-in
\index{CellDesigner!Plug-in}
model\index{Model!CellDesigner} data structures to the translator in JSBML,
which creates then a JSBML \texttt{Model}\index{Model!\texttt{Model}} data structure.
\index{CellDesigner!\texttt{PluginAction}}
\lstinputlisting[language=Java,float,caption={A simple implementation of
CellDesigner's abstract class \texttt{PluginAction}},
label=lst:PluginAction]{SimpleCellDesignerPlugin/org/sbml/jsbml/cdplugin/SimpleCellDesignerPluginAction.java}
% \lstinputlisting[language=Java,float,caption={SimpleCellDesignerPlugin},
% label=lst:Plugin]{SimpleCellDesignerPlugin/org/sbml/jsbml/cdplugin/SimpleCellDesignerPlugin.java}
\begin{lstlisting}[language=Java,float,caption={A simple example for a
CellDesigner plug-in using JSBML as a communication layer},label=lst:Plugin]
package org.sbml.jsbml.cdplugin;

import javax.swing.*;
import jp.sbi.celldesigner.plugin.*;
import org.sbml.jsbml.*;
import org.sbml.jsbml.gui.*;

/** A very simple implementation of a plug-in for CellDesigner. */
public class SimpleCellDesignerPlugin extends CellDesignerPlugin {

  public static final String ACTION = "Display full model tree";
  public static final String APPLICATION_NAME = "Simple Plugin";

  /** Creates a new CellDesigner plug-in with an entry in the menu bar. */
  public SimpleCellDesignerPlugin() {
    super();
    try {
      System.out.printf("\n\nLoading %s\n\n", APPLICATION_NAME);
      SimpleCellDesignerPluginAction action = new SimpleCellDesignerPluginAction(this);
      PluginMenu menu = new PluginMenu(APPLICATION_NAME);
      PluginMenuItem menuItem = new PluginMenuItem(ACTION, action);
      menu.add(menuItem);
      addCellDesignerPluginMenu(menu);
    } catch (Exception exc) {
      exc.printStackTrace();
    }
  }

  /** This method is to be called by our CellDesignerPluginAction. */
  public void startPlugin() {
    PluginSBMLReader reader = new PluginSBMLReader(getSelectedModel(), SBO
        .getDefaultPossibleEnzymes());
    Model model = reader.getModel();
    SBMLDocument doc = new SBMLDocument(model.getLevel(), model
        .getVersion());
    doc.setModel(model);
    new JSBMLvisualizer(doc);
  }

  // Include also methods from super class, not needed in this example.
  public void addPluginMenu() { }
  public void modelClosed(PluginSBase psb) { }
  public void modelOpened(PluginSBase psb) { }
  public void modelSelectChanged(PluginSBase psb) { }
  public void SBaseAdded(PluginSBase psb) { }
  public void SBaseChanged(PluginSBase psb) { }
  public void SBaseDeleted(PluginSBase psb) { }
}
\end{lstlisting}
The examples described by Listings~\vrefrange{lst:PluginAction}{lst:Plugin}
create a plug-in for CellDesigner, which displays the SBML data structure
in a tree, like the example in Fig.~\vref{fig:Visualization}. This example only
shows how to translate a plug-in data structure
from CellDesigner into a corresponding JSBML data structure. With the help of
the class \texttt{PluginSBMLWriter} it is possible to notify CellDesigner about
changes in the model data structure. Note that Listing~\vref{lst:Plugin} is only
completed by implementing the methods from the super class. In this example it
is sufficient to leave the implementation open.

\clearpage
\bibliographystyle{natbib}
\bibliography{literature}

% Index
\printindex

\end{document}
